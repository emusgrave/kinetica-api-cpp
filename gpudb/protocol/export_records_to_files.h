/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __EXPORT_RECORDS_TO_FILES_H__
#define __EXPORT_RECORDS_TO_FILES_H__

namespace gpudb
{

    /**
     * A set of input parameters for {@link
     * #exportRecordsToFiles(const ExportRecordsToFilesRequest&) const}.
     * <p>
     * Export records from a table to files. All tables can be exported, in
     * full or partial
     * (see @a columns_to_export and @a columns_to_skip).
     * Additional filtering can be applied when using export table with
     * expression through SQL.
     * Default destination is KIFS, though other storage types (Azure, S3, GCS,
     * and HDFS) are supported
     * through @a datasink_name; see {@link
     * #createDatasink(const CreateDatasinkRequest&) const}.
     * <p>
     * Server's local file system is not supported.  Default file format is
     * delimited text. See options for
     * different file types and different options for each file type.  Table is
     * saved to a single file if
     * within max file size limits (may vary depending on datasink type).  If
     * not, then table is split into
     * multiple files; these may be smaller than the max size limit.
     * <p>
     * All filenames created are returned in the response.
     */
    struct ExportRecordsToFilesRequest
    {

        /**
         * Constructs an ExportRecordsToFilesRequest object with default
         * parameter values.
         */
        ExportRecordsToFilesRequest() :
            tableName(std::string()),
            filepath(std::string()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs an ExportRecordsToFilesRequest object with the specified
         * parameters.
         * 
         * @param[in] tableName_
         * @param[in] filepath_  Path to data export target.  If @a filepath
         *                       has a file extension, it is
         *                       read as the name of a file. If @a filepath is
         *                       a directory, then the source table name with a
         *                       random UUID appended will be used as the name
         *                       of each exported file, all written to that
         *                       directory.
         *                       If filepath is a filename, then all exported
         *                       files will have a random UUID appended to the
         *                       given
         *                       name.  In either case, the target directory
         *                       specified or implied must exist.  The names of
         *                       all
         *                       exported files are returned in the response.
         * @param[in] options_  Optional parameters.
         *                      <ul>
         *                              <li>
         *                      gpudb::export_records_to_files_batch_size:
         *                      Number of records to be exported as a batch.
         *                      The default value is '1000000'.
         *                              <li>
         *                      gpudb::export_records_to_files_column_formats:
         *                      For each source column specified, applies the
         *                      column-property-bound
         *                      format.  Currently supported column properties
         *                      include date, time, & datetime. The parameter
         *                      value
         *                      must be formatted as a JSON string of maps of
         *                      column names to maps of column properties to
         *                      their
         *                      corresponding column formats, e.g.,
         *                      '{ "order_date" : { "date" : "%Y.%m.%d" },
         *                      "order_time" : { "time" : "%H:%M:%S" } }'.
         *                      See @a default_column_formats for valid format
         *                      syntax.
         *                              <li>
         *                      gpudb::export_records_to_files_columns_to_export:
         *                      Specifies a comma-delimited list of columns
         *                      from the source table to
         *                      export, written to the output file in the order
         *                      they are given.
         *                      Column names can be provided, in which case the
         *                      target file will use those names as the column
         *                      headers as well.
         *                      Alternatively, column numbers can be
         *                      specified--discretely or as a range.  For
         *                      example, a value of
         *                      '5,7,1..3' will write values from the fifth
         *                      column in the source table into the first
         *                      column in the
         *                      target file, from the seventh column in the
         *                      source table into the second column in the
         *                      target file,
         *                      and from the first through third columns in the
         *                      source table into the third through fifth
         *                      columns in
         *                      the target file.
         *                      Mutually exclusive with @a columns_to_skip.
         *                              <li>
         *                      gpudb::export_records_to_files_columns_to_skip:
         *                      Comma-separated list of column names or column
         *                      numbers to not
         *                      export.  All columns in the source table not
         *                      specified will be written to the target file in
         *                      the
         *                      order they appear in the table definition.
         *                      Mutually exclusive with
         *                      @a columns_to_export.
         *                              <li>
         *                      gpudb::export_records_to_files_datasink_name:
         *                      Datasink name, created using /create/datasink.
         *                              <li>
         *                      gpudb::export_records_to_files_default_column_formats:
         *                      Specifies the default format to use to write
         *                      data.  Currently
         *                      supported column properties include date, time,
         *                      & datetime.  This default column-property-bound
         *                      format can be overridden by specifying a column
         *                      property & format for a given source column in
         *                      @a column_formats. For each specified
         *                      annotation, the format will apply to all
         *                      columns with that annotation unless custom @a
         *                      column_formats for that
         *                      annotation are specified.
         *                      The parameter value must be formatted as a JSON
         *                      string that is a map of column properties to
         *                      their
         *                      respective column formats, e.g., '{ "date" :
         *                      "%Y.%m.%d", "time" : "%H:%M:%S" }'.  Column
         *                      formats are specified as a string of control
         *                      characters and plain text. The supported
         *                      control
         *                      characters are 'Y', 'm', 'd', 'H', 'M', 'S',
         *                      and 's', which follow the Linux 'strptime()'
         *                      specification, as well as 's', which specifies
         *                      seconds and fractional seconds (though the
         *                      fractional
         *                      component will be truncated past milliseconds).
         *                      Formats for the 'date' annotation must include
         *                      the 'Y', 'm', and 'd' control characters.
         *                      Formats for
         *                      the 'time' annotation must include the 'H',
         *                      'M', and either 'S' or 's' (but not both)
         *                      control
         *                      characters. Formats for the 'datetime'
         *                      annotation meet both the 'date' and 'time'
         *                      control character
         *                      requirements. For example, '{"datetime" :
         *                      "%m/%d/%Y %H:%M:%S" }' would be used to write
         *                      text
         *                      as "05/04/2000 12:12:11"
         *                              <li>
         *                      gpudb::export_records_to_files_export_ddl: Save
         *                      DDL to a separate file.  The default value is
         *                      'false'.
         *                              <li>
         *                      gpudb::export_records_to_files_file_extension:
         *                      Extension to give the export file.  The default
         *                      value is '.csv'.
         *                              <li>
         *                      gpudb::export_records_to_files_file_type:
         *                      Specifies the file format to use when exporting
         *                      data.
         *                      <ul>
         *                              <li>
         *                      gpudb::export_records_to_files_delimited_text:
         *                      Delimited text file format; e.g., CSV, TSV,
         *                      PSV, etc.
         *                              <li>
         *                      gpudb::export_records_to_files_parquet
         *                      </ul>
         *                      The default value is
         *                      gpudb::export_records_to_files_delimited_text.
         *                              <li>
         *                      gpudb::export_records_to_files_kinetica_header:
         *                      Whether to include a Kinetica proprietary
         *                      header. Will not be
         *                      written if @a text_has_header is
         *                      @a false.
         *                      <ul>
         *                              <li>
         *                      gpudb::export_records_to_files_true
         *                              <li>
         *                      gpudb::export_records_to_files_false
         *                      </ul>
         *                      The default value is
         *                      gpudb::export_records_to_files_false.
         *                              <li>
         *                      gpudb::export_records_to_files_kinetica_header_delimiter:
         *                      If a Kinetica proprietary header is included,
         *                      then specify a
         *                      property separator. Different from column
         *                      delimiter.  The default value is '|'.
         *                              <li>
         *                      gpudb::export_records_to_files_single_file:
         *                      Save records to a single file. This option may
         *                      be ignored if file
         *                      size exceeds internal file size limits (this
         *                      limit will differ on different targets).
         *                      <ul>
         *                              <li>
         *                      gpudb::export_records_to_files_true
         *                              <li>
         *                      gpudb::export_records_to_files_false
         *                      </ul>
         *                      The default value is
         *                      gpudb::export_records_to_files_true.
         *                              <li>
         *                      gpudb::export_records_to_files_text_delimiter:
         *                      Specifies the character to write out to delimit
         *                      field values and
         *                      field names in the header (if present).
         *                      For @a delimited_text @a file_type only.  The
         *                      default value is ','.
         *                              <li>
         *                      gpudb::export_records_to_files_text_has_header:
         *                      Indicates whether to write out a header row.
         *                      For @a delimited_text @a file_type only.
         *                      <ul>
         *                              <li>
         *                      gpudb::export_records_to_files_true
         *                              <li>
         *                      gpudb::export_records_to_files_false
         *                      </ul>
         *                      The default value is
         *                      gpudb::export_records_to_files_true.
         *                              <li>
         *                      gpudb::export_records_to_files_text_null_string:
         *                      Specifies the character string that should be
         *                      written out for the null
         *                      value in the data.
         *                      For @a delimited_text @a file_type only.  The
         *                      default value is '\\N'.
         *                      </ul>
         * 
         */
        ExportRecordsToFilesRequest(const std::string& tableName_, const std::string& filepath_, const std::map<std::string, std::string>& options_):
            tableName( tableName_ ),
            filepath( filepath_ ),
            options( options_ )
        {
        }

        std::string tableName;
        std::string filepath;
        std::map<std::string, std::string> options;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::ExportRecordsToFilesRequest>
    {
        static void encode(Encoder& e, const gpudb::ExportRecordsToFilesRequest& v)
        {
            ::avro::encode(e, v.tableName);
            ::avro::encode(e, v.filepath);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::ExportRecordsToFilesRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.tableName);
                            break;

                        case 1:
                            ::avro::decode(d, v.filepath);
                            break;

                        case 2:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.tableName);
                ::avro::decode(d, v.filepath);
                ::avro::decode(d, v.options);
            }
        }
    };
}

namespace gpudb
{

    /**
     * A set of output parameters for {@link
     * #exportRecordsToFiles(const ExportRecordsToFilesRequest&) const}.
     * <p>
     * Export records from a table to files. All tables can be exported, in
     * full or partial
     * (see @a columns_to_export and @a columns_to_skip).
     * Additional filtering can be applied when using export table with
     * expression through SQL.
     * Default destination is KIFS, though other storage types (Azure, S3, GCS,
     * and HDFS) are supported
     * through @a datasink_name; see {@link
     * #createDatasink(const CreateDatasinkRequest&) const}.
     * <p>
     * Server's local file system is not supported.  Default file format is
     * delimited text. See options for
     * different file types and different options for each file type.  Table is
     * saved to a single file if
     * within max file size limits (may vary depending on datasink type).  If
     * not, then table is split into
     * multiple files; these may be smaller than the max size limit.
     * <p>
     * All filenames created are returned in the response.
     */
    struct ExportRecordsToFilesResponse
    {

        /**
         * Constructs an ExportRecordsToFilesResponse object with default
         * parameter values.
         */
        ExportRecordsToFilesResponse() :
            tableName(std::string()),
            countExported(int64_t()),
            countSkipped(int64_t()),
            files(std::vector<std::string>()),
            lastTimestamp(int64_t()),
            dataText(std::vector<std::string>()),
            dataBytes(std::vector<std::vector<uint8_t> >()),
            info(std::map<std::string, std::string>())
        {
        }

        std::string tableName;
        int64_t countExported;
        int64_t countSkipped;
        std::vector<std::string> files;
        int64_t lastTimestamp;
        std::vector<std::string> dataText;
        std::vector<std::vector<uint8_t> > dataBytes;
        std::map<std::string, std::string> info;
    };
}

namespace avro
{
    template<> struct codec_traits<gpudb::ExportRecordsToFilesResponse>
    {
        static void encode(Encoder& e, const gpudb::ExportRecordsToFilesResponse& v)
        {
            ::avro::encode(e, v.tableName);
            ::avro::encode(e, v.countExported);
            ::avro::encode(e, v.countSkipped);
            ::avro::encode(e, v.files);
            ::avro::encode(e, v.lastTimestamp);
            ::avro::encode(e, v.dataText);
            ::avro::encode(e, v.dataBytes);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::ExportRecordsToFilesResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.tableName);
                            break;

                        case 1:
                            ::avro::decode(d, v.countExported);
                            break;

                        case 2:
                            ::avro::decode(d, v.countSkipped);
                            break;

                        case 3:
                            ::avro::decode(d, v.files);
                            break;

                        case 4:
                            ::avro::decode(d, v.lastTimestamp);
                            break;

                        case 5:
                            ::avro::decode(d, v.dataText);
                            break;

                        case 6:
                            ::avro::decode(d, v.dataBytes);
                            break;

                        case 7:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.tableName);
                ::avro::decode(d, v.countExported);
                ::avro::decode(d, v.countSkipped);
                ::avro::decode(d, v.files);
                ::avro::decode(d, v.lastTimestamp);
                ::avro::decode(d, v.dataText);
                ::avro::decode(d, v.dataBytes);
                ::avro::decode(d, v.info);
            }
        }
    };
}

#endif
