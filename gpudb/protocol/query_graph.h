/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __QUERY_GRAPH_H__
#define __QUERY_GRAPH_H__

namespace gpudb
{
    /**
     * A set of parameters for @ref
     * GPUdb::queryGraph(const QueryGraphRequest&) const "GPUdb::queryGraph".
     *
     * Employs a topological query on a graph generated a-priori by @ref
     * GPUdb::createGraph(const CreateGraphRequest&) const "GPUdb::createGraph"
     * and returns a list of adjacent edge(s) or node(s), also known as an
     * adjacency list, depending on what's been provided to the endpoint;
     * providing edges will return nodes and providing nodes will return edges.
     *
     * To determine the node(s) or edge(s) adjacent to a value from a given
     * column, provide a list of values to @ref queries. This field can be
     * populated with column values from any table as long as the type is
     * supported by the given identifier. See <a
     * href="../../../graph_solver/network_graph_solver/#query-identifiers"
     * target="_top">Query Identifiers</a> for more information.
     *
     * To return the adjacency list in the response, leave @ref adjacencyTable
     * empty.
     *
     * IMPORTANT: It's highly recommended that you review the <a
     * href="../../../graph_solver/network_graph_solver/" target="_top">Graphs
     * & Solvers</a> concepts documentation, the <a
     * href="../../../guides/graph_rest_guide/" target="_top">Graph REST
     * Tutorial</a>, and/or some <a href="../../../guide-tags/graph---query"
     * target="_top">/match/graph examples</a> before using this endpoint.
     */
    struct QueryGraphRequest
    {
        /**
         * Constructs a QueryGraphRequest object with default parameters.
         */
        QueryGraphRequest() :
            graphName(std::string()),
            queries(std::vector<std::string>()),
            restrictions(std::vector<std::string>()),
            adjacencyTable(std::string()),
            rings(int32_t()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs a QueryGraphRequest object with the specified parameters.
         *
         * @param[in] graphName_  Name of the graph resource to query.
         * @param[in] queries_  Nodes or edges to be queried specified using <a
         *                      href="../../../graph_solver/network_graph_solver/#query-identifiers"
         *                      target="_top">query identifiers</a>.
         *                      Identifiers can be used with existing column
         *                      names, e.g., 'table.column AS QUERY_NODE_ID',
         *                      raw values, e.g., '{0, 2} AS QUERY_NODE_ID', or
         *                      expressions, e.g., 'ST_MAKEPOINT(table.x,
         *                      table.y) AS QUERY_NODE_WKTPOINT'. Multiple
         *                      values can be provided as long as the same
         *                      identifier is used for all values. If using raw
         *                      values in an identifier combination, the number
         *                      of values specified must match across the
         *                      combination.
         * @param[in] restrictions_  Additional restrictions to apply to the
         *                           nodes/edges of an existing graph.
         *                           Restrictions must be specified using <a
         *                           href="../../../graph_solver/network_graph_solver/#identifiers"
         *                           target="_top">identifiers</a>; identifiers
         *                           are grouped as <a
         *                           href="../../../graph_solver/network_graph_solver/#id-combos"
         *                           target="_top">combinations</a>.
         *                           Identifiers can be used with existing
         *                           column names, e.g., 'table.column AS
         *                           RESTRICTIONS_EDGE_ID', expressions, e.g.,
         *                           'column/2 AS RESTRICTIONS_VALUECOMPARED',
         *                           or raw values, e.g., '{0, 0, 0, 1} AS
         *                           RESTRICTIONS_ONOFFCOMPARED'. If using raw
         *                           values in an identifier combination, the
         *                           number of values specified must match
         *                           across the combination. The default value
         *                           is an empty vector.
         * @param[in] adjacencyTable_  Name of the table to store the resulting
         *                             adjacencies, in [schema_name.]table_name
         *                             format, using standard <a
         *                             href="../../../concepts/tables/#table-name-resolution"
         *                             target="_top">name resolution rules</a>
         *                             and meeting <a
         *                             href="../../../concepts/tables/#table-naming-criteria"
         *                             target="_top">table naming criteria</a>.
         *                             If left blank, the query results are
         *                             instead returned in the response. If the
         *                             'QUERY_TARGET_NODE_LABEL' <a
         *                             href="../../../graph_solver/network_graph_solver/#query-identifiers"
         *                             target="_top">query identifier</a> is
         *                             used in @a queries_, then two additional
         *                             columns will be available: 'PATH_ID' and
         *                             'RING_ID'. See <a
         *                             href="../../../graph_solver/network_graph_solver/#using-labels"
         *                             target="_top">Using Labels</a> for more
         *                             information. The default value is ''.
         * @param[in] rings_  Sets the number of rings around the node to query
         *                    for adjacency, with '1' being the edges directly
         *                    attached to the queried node. Also known as
         *                    number of hops. For example, if it is set to '2',
         *                    the edge(s) directly attached to the queried
         *                    node(s) will be returned; in addition, the
         *                    edge(s) attached to the node(s) attached to the
         *                    initial ring of edge(s) surrounding the queried
         *                    node(s) will be returned. If the value is set to
         *                    '0', any nodes that meet the criteria in @a
         *                    queries_ and @a restrictions_ will be returned.
         *                    This parameter is only applicable when querying
         *                    nodes. The default value is 1.
         * @param[in] options_  Additional parameters.
         *                      <ul>
         *                          <li>@ref
         *                              gpudb::query_graph_force_undirected
         *                              "query_graph_force_undirected": If set
         *                              to @ref gpudb::query_graph_true "true",
         *                              all inbound edges and outbound edges
         *                              relative to the node will be returned.
         *                              If set to @ref gpudb::query_graph_false
         *                              "false", only outbound edges relative
         *                              to the node will be returned. This
         *                              parameter is only applicable if the
         *                              queried graph @a graphName_ is directed
         *                              and when querying nodes. Consult <a
         *                              href="../../../graph_solver/network_graph_solver/#directed-graphs"
         *                              target="_top">Directed Graphs</a> for
         *                              more details.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref gpudb::query_graph_true
         *                                      "query_graph_true"
         *                                  <li>@ref gpudb::query_graph_false
         *                                      "query_graph_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::query_graph_false
         *                              "query_graph_false".
         *                          <li>@ref gpudb::query_graph_limit
         *                              "query_graph_limit": When specified
         *                              (&gt;0), limits the number of query
         *                              results. The size of the nodes table
         *                              will be limited by the @ref
         *                              gpudb::query_graph_limit "limit" value.
         *                              The default value is '0'.
         *                          <li>@ref gpudb::query_graph_output_wkt_path
         *                              "query_graph_output_wkt_path": If true
         *                              then concatenated wkt line segments
         *                              will be added as the WKT column of the
         *                              adjacency table.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref gpudb::query_graph_true
         *                                      "query_graph_true"
         *                                  <li>@ref gpudb::query_graph_false
         *                                      "query_graph_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::query_graph_false
         *                              "query_graph_false".
         *                          <li>@ref gpudb::query_graph_and_labels
         *                              "query_graph_and_labels": If set to
         *                              @ref gpudb::query_graph_true "true",
         *                              the result of the query has entities
         *                              that satisfy all of the target labels,
         *                              instead of any.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref gpudb::query_graph_true
         *                                      "query_graph_true"
         *                                  <li>@ref gpudb::query_graph_false
         *                                      "query_graph_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::query_graph_false
         *                              "query_graph_false".
         *                          <li>@ref gpudb::query_graph_server_id
         *                              "query_graph_server_id": Indicates
         *                              which graph server(s) to send the
         *                              request to. Default is to send to the
         *                              server, amongst those containing the
         *                              corresponding graph, that has the most
         *                              computational bandwidth.
         *                          <li>@ref
         *                              gpudb::query_graph_output_charn_length
         *                              "query_graph_output_charn_length": When
         *                              specified (&gt;0 and &lt;=256), limits
         *                              the number of char length on the output
         *                              tables for string based nodes. The
         *                              default length is 64. The default value
         *                              is '64'.
         *                          <li>@ref
         *                              gpudb::query_graph_find_common_labels
         *                              "query_graph_find_common_labels": If
         *                              set to true, for many-to-many queries
         *                              or multi-level traversals, it lists the
         *                              common labels between the source and
         *                              target nodes and edge labels in each
         *                              path. Otherwise (zero rings), it'll
         *                              list all labels of the node(s) queried.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref gpudb::query_graph_true
         *                                      "query_graph_true"
         *                                  <li>@ref gpudb::query_graph_false
         *                                      "query_graph_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::query_graph_false
         *                              "query_graph_false".
         *                      </ul>
         *                      The default value is an empty map.
         */
        QueryGraphRequest(const std::string& graphName_, const std::vector<std::string>& queries_, const std::vector<std::string>& restrictions_, const std::string& adjacencyTable_, const int32_t rings_, const std::map<std::string, std::string>& options_):
            graphName( graphName_ ),
            queries( queries_ ),
            restrictions( restrictions_ ),
            adjacencyTable( adjacencyTable_ ),
            rings( rings_ ),
            options( options_ )
        {
        }

        /**
         * Name of the graph resource to query.
         */
        std::string graphName;

        /**
         * Nodes or edges to be queried specified using <a
         * href="../../../graph_solver/network_graph_solver/#query-identifiers"
         * target="_top">query identifiers</a>. Identifiers can be used with
         * existing column names, e.g., 'table.column AS QUERY_NODE_ID', raw
         * values, e.g., '{0, 2} AS QUERY_NODE_ID', or expressions, e.g.,
         * 'ST_MAKEPOINT(table.x, table.y) AS QUERY_NODE_WKTPOINT'. Multiple
         * values can be provided as long as the same identifier is used for
         * all values. If using raw values in an identifier combination, the
         * number of values specified must match across the combination.
         */
        std::vector<std::string> queries;

        /**
         * Additional restrictions to apply to the nodes/edges of an existing
         * graph. Restrictions must be specified using <a
         * href="../../../graph_solver/network_graph_solver/#identifiers"
         * target="_top">identifiers</a>; identifiers are grouped as <a
         * href="../../../graph_solver/network_graph_solver/#id-combos"
         * target="_top">combinations</a>. Identifiers can be used with
         * existing column names, e.g., 'table.column AS RESTRICTIONS_EDGE_ID',
         * expressions, e.g., 'column/2 AS RESTRICTIONS_VALUECOMPARED', or raw
         * values, e.g., '{0, 0, 0, 1} AS RESTRICTIONS_ONOFFCOMPARED'. If using
         * raw values in an identifier combination, the number of values
         * specified must match across the combination. The default value is an
         * empty vector.
         */
        std::vector<std::string> restrictions;

        /**
         * Name of the table to store the resulting adjacencies, in [
         * schema_name.\ ]table_name format, using standard <a
         * href="../../../concepts/tables/#table-name-resolution"
         * target="_top">name resolution rules</a> and meeting <a
         * href="../../../concepts/tables/#table-naming-criteria"
         * target="_top">table naming criteria</a>.  If left blank, the query
         * results are instead returned in the response. If the
         * 'QUERY_TARGET_NODE_LABEL' <a
         * href="../../../graph_solver/network_graph_solver/#query-identifiers"
         * target="_top">query identifier</a> is used in @ref queries, then two
         * additional columns will be available: 'PATH_ID' and 'RING_ID'. See
         * <a href="../../../graph_solver/network_graph_solver/#using-labels"
         * target="_top">Using Labels</a> for more information. The default
         * value is ''.
         */
        std::string adjacencyTable;

        /**
         * Sets the number of rings around the node to query for adjacency,
         * with '1' being the edges directly attached to the queried node. Also
         * known as number of hops. For example, if it is set to '2', the
         * edge(s) directly attached to the queried node(s) will be returned;
         * in addition, the edge(s) attached to the node(s) attached to the
         * initial ring of edge(s) surrounding the queried node(s) will be
         * returned. If the value is set to '0', any nodes that meet the
         * criteria in @ref queries and @ref restrictions will be returned.
         * This parameter is only applicable when querying nodes. The default
         * value is 1.
         */
        int32_t rings;

        /**
         * Additional parameters.
         * <ul>
         *     <li>@ref gpudb::query_graph_force_undirected
         *         "query_graph_force_undirected": If set to @ref
         *         gpudb::query_graph_true "true", all inbound edges and
         *         outbound edges relative to the node will be returned. If set
         *         to @ref gpudb::query_graph_false "false", only outbound
         *         edges relative to the node will be returned. This parameter
         *         is only applicable if the queried graph @ref graphName is
         *         directed and when querying nodes. Consult <a
         *         href="../../../graph_solver/network_graph_solver/#directed-graphs"
         *         target="_top">Directed Graphs</a> for more details.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::query_graph_true "query_graph_true"
         *             <li>@ref gpudb::query_graph_false "query_graph_false"
         *         </ul>
         *         The default value is @ref gpudb::query_graph_false
         *         "query_graph_false".
         *     <li>@ref gpudb::query_graph_limit "query_graph_limit": When
         *         specified (&gt;0), limits the number of query results. The
         *         size of the nodes table will be limited by the @ref
         *         gpudb::query_graph_limit "limit" value. The default value is
         *         '0'.
         *     <li>@ref gpudb::query_graph_output_wkt_path
         *         "query_graph_output_wkt_path": If true then concatenated wkt
         *         line segments will be added as the WKT column of the
         *         adjacency table.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::query_graph_true "query_graph_true"
         *             <li>@ref gpudb::query_graph_false "query_graph_false"
         *         </ul>
         *         The default value is @ref gpudb::query_graph_false
         *         "query_graph_false".
         *     <li>@ref gpudb::query_graph_and_labels "query_graph_and_labels":
         *         If set to @ref gpudb::query_graph_true "true", the result of
         *         the query has entities that satisfy all of the target
         *         labels, instead of any.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::query_graph_true "query_graph_true"
         *             <li>@ref gpudb::query_graph_false "query_graph_false"
         *         </ul>
         *         The default value is @ref gpudb::query_graph_false
         *         "query_graph_false".
         *     <li>@ref gpudb::query_graph_server_id "query_graph_server_id":
         *         Indicates which graph server(s) to send the request to.
         *         Default is to send to the server, amongst those containing
         *         the corresponding graph, that has the most computational
         *         bandwidth.
         *     <li>@ref gpudb::query_graph_output_charn_length
         *         "query_graph_output_charn_length": When specified (&gt;0 and
         *         &lt;=256), limits the number of char length on the output
         *         tables for string based nodes. The default length is 64. The
         *         default value is '64'.
         *     <li>@ref gpudb::query_graph_find_common_labels
         *         "query_graph_find_common_labels": If set to true, for
         *         many-to-many queries or multi-level traversals, it lists the
         *         common labels between the source and target nodes and edge
         *         labels in each path. Otherwise (zero rings), it'll list all
         *         labels of the node(s) queried.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::query_graph_true "query_graph_true"
         *             <li>@ref gpudb::query_graph_false "query_graph_false"
         *         </ul>
         *         The default value is @ref gpudb::query_graph_false
         *         "query_graph_false".
         * </ul>
         * The default value is an empty map.
         */
        std::map<std::string, std::string> options;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::QueryGraphRequest>
    {
        static void encode(Encoder& e, const gpudb::QueryGraphRequest& v)
        {
            ::avro::encode(e, v.graphName);
            ::avro::encode(e, v.queries);
            ::avro::encode(e, v.restrictions);
            ::avro::encode(e, v.adjacencyTable);
            ::avro::encode(e, v.rings);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::QueryGraphRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.graphName);
                            break;

                        case 1:
                            ::avro::decode(d, v.queries);
                            break;

                        case 2:
                            ::avro::decode(d, v.restrictions);
                            break;

                        case 3:
                            ::avro::decode(d, v.adjacencyTable);
                            break;

                        case 4:
                            ::avro::decode(d, v.rings);
                            break;

                        case 5:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.graphName);
                ::avro::decode(d, v.queries);
                ::avro::decode(d, v.restrictions);
                ::avro::decode(d, v.adjacencyTable);
                ::avro::decode(d, v.rings);
                ::avro::decode(d, v.options);
            }
        }
    };
} // end namespace avro

namespace gpudb
{
    /**
     * A set of results returned by @ref
     * GPUdb::queryGraph(const QueryGraphRequest&) const "GPUdb::queryGraph".
     */
    struct QueryGraphResponse
    {
        /**
         * Constructs a QueryGraphResponse object with default parameters.
         */
        QueryGraphResponse() :
            result(bool()),
            adjacencyListIntArray(std::vector<int64_t>()),
            adjacencyListStringArray(std::vector<std::string>()),
            adjacencyListWktArray(std::vector<std::string>()),
            info(std::map<std::string, std::string>())
        {
        }

        /**
         * Indicates a successful query.
         */
        bool result;

        /**
         * The adjacency entity integer ID: either edge IDs per node requested
         * (if using QUERY_EDGE_ID or QUERY_NODE1_ID and QUERY_NODE2_ID in the
         * input) or two node IDs per edge requested (if using QUERY_NODE_ID in
         * the input).
         */
        std::vector<int64_t> adjacencyListIntArray;

        /**
         * The adjacency entity string ID: either edge IDs per node requested
         * (if using QUERY_EDGE_NAME or QUERY_NODE1_NAME and QUERY_NODE2_NAME
         * in the input) or two node IDs per edge requested (if using
         * QUERY_NODE_NAME in the input).
         */
        std::vector<std::string> adjacencyListStringArray;

        /**
         * The adjacency entity WKTPOINT or WKTLINE ID: either edge IDs per
         * node requested (if using QUERY_EDGE_WKTLINE or QUERY_NODE1_WKTPOINT
         * and QUERY_NODE2_WKTPOINT in the input) or two node IDs per edge
         * requested (if using QUERY_NODE_WKTPOINT in the input).
         */
        std::vector<std::string> adjacencyListWktArray;

        /**
         * Additional information.
         */
        std::map<std::string, std::string> info;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::QueryGraphResponse>
    {
        static void encode(Encoder& e, const gpudb::QueryGraphResponse& v)
        {
            ::avro::encode(e, v.result);
            ::avro::encode(e, v.adjacencyListIntArray);
            ::avro::encode(e, v.adjacencyListStringArray);
            ::avro::encode(e, v.adjacencyListWktArray);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::QueryGraphResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.result);
                            break;

                        case 1:
                            ::avro::decode(d, v.adjacencyListIntArray);
                            break;

                        case 2:
                            ::avro::decode(d, v.adjacencyListStringArray);
                            break;

                        case 3:
                            ::avro::decode(d, v.adjacencyListWktArray);
                            break;

                        case 4:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.result);
                ::avro::decode(d, v.adjacencyListIntArray);
                ::avro::decode(d, v.adjacencyListStringArray);
                ::avro::decode(d, v.adjacencyListWktArray);
                ::avro::decode(d, v.info);
            }
        }
    };
} // end namespace avro

#endif // __QUERY_GRAPH_H__
