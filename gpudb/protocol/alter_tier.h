/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __ALTER_TIER_H__
#define __ALTER_TIER_H__

namespace gpudb
{
    /**
     * A set of parameters for @ref
     * GPUdb::alterTier(const AlterTierRequest&) const "GPUdb::alterTier".
     *
     * Alters properties of an exisiting <a
     * href="../../../rm/concepts/#storage-tiers" target="_top">tier</a> to
     * facilitate <a href="../../../rm/concepts/" target="_top">resource
     * management</a>.
     *
     * To disable <a href="../../../rm/concepts/#watermark-based-eviction"
     * target="_top">watermark-based eviction</a>, set both @ref
     * gpudb::alter_tier_high_watermark "high_watermark" and @ref
     * gpudb::alter_tier_low_watermark "low_watermark" to 100.
     */
    struct AlterTierRequest
    {
        /**
         * Constructs an AlterTierRequest object with default parameters.
         */
        AlterTierRequest() :
            name(std::string()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs an AlterTierRequest object with the specified parameters.
         *
         * @param[in] name_  Name of the tier to be altered. Must be an
         *                   existing tier group name.
         * @param[in] options_  Optional parameters.
         *                      <ul>
         *                          <li>@ref gpudb::alter_tier_capacity
         *                              "alter_tier_capacity": Maximum size in
         *                              bytes this tier may hold at once.
         *                          <li>@ref gpudb::alter_tier_high_watermark
         *                              "alter_tier_high_watermark": Threshold
         *                              of usage of this tier's resource that
         *                              once exceeded, will trigger
         *                              watermark-based eviction from this
         *                              tier. The minimum allowed value is '0'.
         *                              The maximum allowed value is '100'.
         *                          <li>@ref gpudb::alter_tier_low_watermark
         *                              "alter_tier_low_watermark": Threshold
         *                              of resource usage that once fallen
         *                              below after crossing the @ref
         *                              gpudb::alter_tier_high_watermark
         *                              "high_watermark", will cease
         *                              watermark-based eviction from this
         *                              tier. The minimum allowed value is '0'.
         *                              The maximum allowed value is '100'.
         *                          <li>@ref gpudb::alter_tier_wait_timeout
         *                              "alter_tier_wait_timeout": Timeout in
         *                              seconds for reading from or writing to
         *                              this resource. Applies to cold storage
         *                              tiers only.
         *                          <li>@ref gpudb::alter_tier_persist
         *                              "alter_tier_persist": If @ref
         *                              gpudb::alter_tier_true "true" the
         *                              system configuration will be written to
         *                              disk upon successful application of
         *                              this request. This will commit the
         *                              changes from this request and any
         *                              additional in-memory modifications.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref gpudb::alter_tier_true
         *                                      "alter_tier_true"
         *                                  <li>@ref gpudb::alter_tier_false
         *                                      "alter_tier_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::alter_tier_true
         *                              "alter_tier_true".
         *                          <li>@ref gpudb::alter_tier_rank
         *                              "alter_tier_rank": Apply the requested
         *                              change only to a specific rank. The
         *                              minimum allowed value is '0'. The
         *                              maximum allowed value is '10000'.
         *                      </ul>
         *                      The default value is an empty map.
         */
        AlterTierRequest(const std::string& name_, const std::map<std::string, std::string>& options_):
            name( name_ ),
            options( options_ )
        {
        }

        /**
         * Name of the tier to be altered. Must be an existing tier group name.
         */
        std::string name;

        /**
         * Optional parameters.
         * <ul>
         *     <li>@ref gpudb::alter_tier_capacity "alter_tier_capacity":
         *         Maximum size in bytes this tier may hold at once.
         *     <li>@ref gpudb::alter_tier_high_watermark
         *         "alter_tier_high_watermark": Threshold of usage of this
         *         tier's resource that once exceeded, will trigger
         *         watermark-based eviction from this tier. The minimum allowed
         *         value is '0'. The maximum allowed value is '100'.
         *     <li>@ref gpudb::alter_tier_low_watermark
         *         "alter_tier_low_watermark": Threshold of resource usage that
         *         once fallen below after crossing the @ref
         *         gpudb::alter_tier_high_watermark "high_watermark", will
         *         cease watermark-based eviction from this tier. The minimum
         *         allowed value is '0'. The maximum allowed value is '100'.
         *     <li>@ref gpudb::alter_tier_wait_timeout
         *         "alter_tier_wait_timeout": Timeout in seconds for reading
         *         from or writing to this resource. Applies to cold storage
         *         tiers only.
         *     <li>@ref gpudb::alter_tier_persist "alter_tier_persist": If @ref
         *         gpudb::alter_tier_true "true" the system configuration will
         *         be written to disk upon successful application of this
         *         request. This will commit the changes from this request and
         *         any additional in-memory modifications.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::alter_tier_true "alter_tier_true"
         *             <li>@ref gpudb::alter_tier_false "alter_tier_false"
         *         </ul>
         *         The default value is @ref gpudb::alter_tier_true
         *         "alter_tier_true".
         *     <li>@ref gpudb::alter_tier_rank "alter_tier_rank": Apply the
         *         requested change only to a specific rank. The minimum
         *         allowed value is '0'. The maximum allowed value is '10000'.
         * </ul>
         * The default value is an empty map.
         */
        std::map<std::string, std::string> options;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::AlterTierRequest>
    {
        static void encode(Encoder& e, const gpudb::AlterTierRequest& v)
        {
            ::avro::encode(e, v.name);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::AlterTierRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.name);
                            break;

                        case 1:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.name);
                ::avro::decode(d, v.options);
            }
        }
    };
} // end namespace avro

namespace gpudb
{
    /**
     * A set of results returned by @ref
     * GPUdb::alterTier(const AlterTierRequest&) const "GPUdb::alterTier".
     */
    struct AlterTierResponse
    {
        /**
         * Constructs an AlterTierResponse object with default parameters.
         */
        AlterTierResponse() :
            name(std::string()),
            info(std::map<std::string, std::string>())
        {
        }

        /**
         * Value of @ref gpudb::AlterTierRequest::name "name".
         */
        std::string name;

        /**
         * Additional information.
         */
        std::map<std::string, std::string> info;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::AlterTierResponse>
    {
        static void encode(Encoder& e, const gpudb::AlterTierResponse& v)
        {
            ::avro::encode(e, v.name);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::AlterTierResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.name);
                            break;

                        case 1:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.name);
                ::avro::decode(d, v.info);
            }
        }
    };
} // end namespace avro

#endif // __ALTER_TIER_H__
