/*
 *  This file was autogenerated by the Kinetica schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
#ifndef __AGGREGATE_K_MEANS_H__
#define __AGGREGATE_K_MEANS_H__

namespace gpudb
{
    /**
     * A set of parameters for @ref
     * GPUdb::aggregateKMeans(const AggregateKMeansRequest&) const
     * "GPUdb::aggregateKMeans".
     *
     * This endpoint runs the k-means algorithm - a heuristic algorithm that
     * attempts to do k-means clustering.  An ideal k-means clustering
     * algorithm selects k points such that the sum of the mean squared
     * distances of each member of the set to the nearest of the k points is
     * minimized.  The k-means algorithm however does not necessarily produce
     * such an ideal cluster.   It begins with a randomly selected set of k
     * points and then refines the location of the points iteratively and
     * settles to a local minimum.  Various parameters and options are provided
     * to control the heuristic search.
     *
     * NOTE:  The Kinetica instance being accessed must be running a CUDA
     * (GPU-based) build to service this request.
     */
    struct AggregateKMeansRequest
    {
        /**
         * Constructs an AggregateKMeansRequest object with default parameters.
         */
        AggregateKMeansRequest() :
            tableName(std::string()),
            columnNames(std::vector<std::string>()),
            k(int32_t()),
            tolerance(double()),
            options(std::map<std::string, std::string>())
        {
        }

        /**
         * Constructs an AggregateKMeansRequest object with the specified
         * parameters.
         *
         * @param[in] tableName_  Name of the table on which the operation will
         *                        be performed. Must be an existing table, in
         *                        [schema_name.]table_name format, using
         *                        standard <a
         *                        href="../../../concepts/tables/#table-name-resolution"
         *                        target="_top">name resolution rules</a>.
         * @param[in] columnNames_  List of column names on which the operation
         *                          would be performed. If n columns are
         *                          provided then each of the k result points
         *                          will have n dimensions corresponding to the
         *                          n columns.
         * @param[in] k_  The number of mean points to be determined by the
         *                algorithm.
         * @param[in] tolerance_  Stop iterating when the distances between
         *                        successive points is less than the given
         *                        tolerance.
         * @param[in] options_  Optional parameters.
         *                      <ul>
         *                          <li>@ref gpudb::aggregate_k_means_whiten
         *                              "aggregate_k_means_whiten": When set to
         *                              1 each of the columns is first
         *                              normalized by its stdv - default is not
         *                              to whiten.
         *                          <li>@ref gpudb::aggregate_k_means_max_iters
         *                              "aggregate_k_means_max_iters": Number
         *                              of times to try to hit the tolerance
         *                              limit before giving up - default is 10.
         *                          <li>@ref gpudb::aggregate_k_means_num_tries
         *                              "aggregate_k_means_num_tries": Number
         *                              of times to run the k-means algorithm
         *                              with a different randomly selected
         *                              starting points - helps avoid local
         *                              minimum. Default is 1.
         *                          <li>@ref
         *                              gpudb::aggregate_k_means_create_temp_table
         *                              "aggregate_k_means_create_temp_table":
         *                              If @ref gpudb::aggregate_k_means_true
         *                              "true", a unique temporary table name
         *                              will be generated in the sys_temp
         *                              schema and used in place of @ref
         *                              gpudb::aggregate_k_means_result_table
         *                              "result_table". If @ref
         *                              gpudb::aggregate_k_means_result_table_persist
         *                              "result_table_persist" is @ref
         *                              gpudb::aggregate_k_means_false "false"
         *                              (or unspecified), then this is always
         *                              allowed even if the caller does not
         *                              have permission to create tables. The
         *                              generated name is returned in @ref
         *                              gpudb::aggregate_k_means_qualified_result_table_name
         *                              "qualified_result_table_name".
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref
         *                                      gpudb::aggregate_k_means_true
         *                                      "aggregate_k_means_true"
         *                                  <li>@ref
         *                                      gpudb::aggregate_k_means_false
         *                                      "aggregate_k_means_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::aggregate_k_means_false
         *                              "aggregate_k_means_false".
         *                          <li>@ref
         *                              gpudb::aggregate_k_means_result_table
         *                              "aggregate_k_means_result_table": The
         *                              name of a table used to store the
         *                              results, in [schema_name.]table_name
         *                              format, using standard <a
         *                              href="../../../concepts/tables/#table-name-resolution"
         *                              target="_top">name resolution rules</a>
         *                              and meeting <a
         *                              href="../../../concepts/tables/#table-naming-criteria"
         *                              target="_top">table naming
         *                              criteria</a>.  If this option is
         *                              specified, the results are not returned
         *                              in the response.
         *                          <li>@ref
         *                              gpudb::aggregate_k_means_result_table_persist
         *                              "aggregate_k_means_result_table_persist":
         *                              If @ref gpudb::aggregate_k_means_true
         *                              "true", then the result table specified
         *                              in @ref
         *                              gpudb::aggregate_k_means_result_table
         *                              "result_table" will be persisted and
         *                              will not expire unless a @ref
         *                              gpudb::aggregate_k_means_ttl "ttl" is
         *                              specified.   If @ref
         *                              gpudb::aggregate_k_means_false "false",
         *                              then the result table will be an
         *                              in-memory table and will expire unless
         *                              a @ref gpudb::aggregate_k_means_ttl
         *                              "ttl" is specified otherwise.
         *                              Supported values:
         *                              <ul>
         *                                  <li>@ref
         *                                      gpudb::aggregate_k_means_true
         *                                      "aggregate_k_means_true"
         *                                  <li>@ref
         *                                      gpudb::aggregate_k_means_false
         *                                      "aggregate_k_means_false"
         *                              </ul>
         *                              The default value is @ref
         *                              gpudb::aggregate_k_means_false
         *                              "aggregate_k_means_false".
         *                          <li>@ref gpudb::aggregate_k_means_ttl
         *                              "aggregate_k_means_ttl": Sets the <a
         *                              href="../../../concepts/ttl/"
         *                              target="_top">TTL</a> of the table
         *                              specified in @ref
         *                              gpudb::aggregate_k_means_result_table
         *                              "result_table".
         *                      </ul>
         *                      The default value is an empty map.
         */
        AggregateKMeansRequest(const std::string& tableName_, const std::vector<std::string>& columnNames_, const int32_t k_, const double tolerance_, const std::map<std::string, std::string>& options_):
            tableName( tableName_ ),
            columnNames( columnNames_ ),
            k( k_ ),
            tolerance( tolerance_ ),
            options( options_ )
        {
        }

        /**
         * Name of the table on which the operation will be performed. Must be
         * an existing table, in [ schema_name.\ ]table_name format, using
         * standard <a href="../../../concepts/tables/#table-name-resolution"
         * target="_top">name resolution rules</a>.
         */
        std::string tableName;

        /**
         * List of column names on which the operation would be performed. If n
         * columns are provided then each of the k result points will have n
         * dimensions corresponding to the n columns.
         */
        std::vector<std::string> columnNames;

        /**
         * The number of mean points to be determined by the algorithm.
         */
        int32_t k;

        /**
         * Stop iterating when the distances between successive points is less
         * than the given tolerance.
         */
        double tolerance;

        /**
         * Optional parameters.
         * <ul>
         *     <li>@ref gpudb::aggregate_k_means_whiten
         *         "aggregate_k_means_whiten": When set to 1 each of the
         *         columns is first normalized by its stdv - default is not to
         *         whiten.
         *     <li>@ref gpudb::aggregate_k_means_max_iters
         *         "aggregate_k_means_max_iters": Number of times to try to hit
         *         the tolerance limit before giving up - default is 10.
         *     <li>@ref gpudb::aggregate_k_means_num_tries
         *         "aggregate_k_means_num_tries": Number of times to run the
         *         k-means algorithm with a different randomly selected
         *         starting points - helps avoid local minimum. Default is 1.
         *     <li>@ref gpudb::aggregate_k_means_create_temp_table
         *         "aggregate_k_means_create_temp_table": If @ref
         *         gpudb::aggregate_k_means_true "true", a unique temporary
         *         table name will be generated in the sys_temp schema and used
         *         in place of @ref gpudb::aggregate_k_means_result_table
         *         "result_table". If @ref
         *         gpudb::aggregate_k_means_result_table_persist
         *         "result_table_persist" is @ref
         *         gpudb::aggregate_k_means_false "false" (or unspecified),
         *         then this is always allowed even if the caller does not have
         *         permission to create tables. The generated name is returned
         *         in @ref gpudb::aggregate_k_means_qualified_result_table_name
         *         "qualified_result_table_name".
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::aggregate_k_means_true
         *                 "aggregate_k_means_true"
         *             <li>@ref gpudb::aggregate_k_means_false
         *                 "aggregate_k_means_false"
         *         </ul>
         *         The default value is @ref gpudb::aggregate_k_means_false
         *         "aggregate_k_means_false".
         *     <li>@ref gpudb::aggregate_k_means_result_table
         *         "aggregate_k_means_result_table": The name of a table used
         *         to store the results, in [schema_name.]table_name format,
         *         using standard <a
         *         href="../../../concepts/tables/#table-name-resolution"
         *         target="_top">name resolution rules</a> and meeting <a
         *         href="../../../concepts/tables/#table-naming-criteria"
         *         target="_top">table naming criteria</a>.  If this option is
         *         specified, the results are not returned in the response.
         *     <li>@ref gpudb::aggregate_k_means_result_table_persist
         *         "aggregate_k_means_result_table_persist": If @ref
         *         gpudb::aggregate_k_means_true "true", then the result table
         *         specified in @ref gpudb::aggregate_k_means_result_table
         *         "result_table" will be persisted and will not expire unless
         *         a @ref gpudb::aggregate_k_means_ttl "ttl" is specified.   If
         *         @ref gpudb::aggregate_k_means_false "false", then the result
         *         table will be an in-memory table and will expire unless a
         *         @ref gpudb::aggregate_k_means_ttl "ttl" is specified
         *         otherwise.
         *         Supported values:
         *         <ul>
         *             <li>@ref gpudb::aggregate_k_means_true
         *                 "aggregate_k_means_true"
         *             <li>@ref gpudb::aggregate_k_means_false
         *                 "aggregate_k_means_false"
         *         </ul>
         *         The default value is @ref gpudb::aggregate_k_means_false
         *         "aggregate_k_means_false".
         *     <li>@ref gpudb::aggregate_k_means_ttl "aggregate_k_means_ttl":
         *         Sets the <a href="../../../concepts/ttl/"
         *         target="_top">TTL</a> of the table specified in @ref
         *         gpudb::aggregate_k_means_result_table "result_table".
         * </ul>
         * The default value is an empty map.
         */
        std::map<std::string, std::string> options;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::AggregateKMeansRequest>
    {
        static void encode(Encoder& e, const gpudb::AggregateKMeansRequest& v)
        {
            ::avro::encode(e, v.tableName);
            ::avro::encode(e, v.columnNames);
            ::avro::encode(e, v.k);
            ::avro::encode(e, v.tolerance);
            ::avro::encode(e, v.options);
        }

        static void decode(Decoder& d, gpudb::AggregateKMeansRequest& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.tableName);
                            break;

                        case 1:
                            ::avro::decode(d, v.columnNames);
                            break;

                        case 2:
                            ::avro::decode(d, v.k);
                            break;

                        case 3:
                            ::avro::decode(d, v.tolerance);
                            break;

                        case 4:
                            ::avro::decode(d, v.options);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.tableName);
                ::avro::decode(d, v.columnNames);
                ::avro::decode(d, v.k);
                ::avro::decode(d, v.tolerance);
                ::avro::decode(d, v.options);
            }
        }
    };
} // end namespace avro

namespace gpudb
{
    /**
     * A set of results returned by @ref
     * GPUdb::aggregateKMeans(const AggregateKMeansRequest&) const
     * "GPUdb::aggregateKMeans".
     */
    struct AggregateKMeansResponse
    {
        /**
         * Constructs an AggregateKMeansResponse object with default
         * parameters.
         */
        AggregateKMeansResponse() :
            means(std::vector<std::vector<double> >()),
            counts(std::vector<int64_t>()),
            rmsDists(std::vector<double>()),
            count(int64_t()),
            rmsDist(double()),
            tolerance(double()),
            numIters(int32_t()),
            info(std::map<std::string, std::string>())
        {
        }

        /**
         * The k-mean values found.
         */
        std::vector<std::vector<double> > means;

        /**
         * The number of elements in the cluster closest the corresponding
         * k-means values.
         */
        std::vector<int64_t> counts;

        /**
         * The root mean squared distance of the elements in the cluster for
         * each of the k-means values.
         */
        std::vector<double> rmsDists;

        /**
         * The total count of all the clusters - will be the size of the input
         * table.
         */
        int64_t count;

        /**
         * The sum of all the rms_dists - the value the k-means algorithm is
         * attempting to minimize.
         */
        double rmsDist;

        /**
         * The distance between the last two iterations of the algorithm before
         * it quit.
         */
        double tolerance;

        /**
         * The number of iterations the algorithm executed before it quit.
         */
        int32_t numIters;

        /**
         * Additional information.
         * <ul>
         *     <li>@ref gpudb::aggregate_k_means_qualified_result_table_name
         *         "aggregate_k_means_qualified_result_table_name": The fully
         *         qualified name of the result table (i.e. including the
         *         schema) used to store the results.
         * </ul>
         * The default value is an empty map.
         */
        std::map<std::string, std::string> info;
    };
} // end namespace gpudb

namespace avro
{
    template<> struct codec_traits<gpudb::AggregateKMeansResponse>
    {
        static void encode(Encoder& e, const gpudb::AggregateKMeansResponse& v)
        {
            ::avro::encode(e, v.means);
            ::avro::encode(e, v.counts);
            ::avro::encode(e, v.rmsDists);
            ::avro::encode(e, v.count);
            ::avro::encode(e, v.rmsDist);
            ::avro::encode(e, v.tolerance);
            ::avro::encode(e, v.numIters);
            ::avro::encode(e, v.info);
        }

        static void decode(Decoder& d, gpudb::AggregateKMeansResponse& v)
        {
            if (::avro::ResolvingDecoder *rd = dynamic_cast< ::avro::ResolvingDecoder*>(&d))
            {
                const std::vector<size_t> fo = rd->fieldOrder();

                for (std::vector<size_t>::const_iterator it = fo.begin(); it != fo.end(); ++it)
                {
                    switch (*it)
                    {
                        case 0:
                            ::avro::decode(d, v.means);
                            break;

                        case 1:
                            ::avro::decode(d, v.counts);
                            break;

                        case 2:
                            ::avro::decode(d, v.rmsDists);
                            break;

                        case 3:
                            ::avro::decode(d, v.count);
                            break;

                        case 4:
                            ::avro::decode(d, v.rmsDist);
                            break;

                        case 5:
                            ::avro::decode(d, v.tolerance);
                            break;

                        case 6:
                            ::avro::decode(d, v.numIters);
                            break;

                        case 7:
                            ::avro::decode(d, v.info);
                            break;

                        default:
                            break;
                    }
                }
            }
            else
            {
                ::avro::decode(d, v.means);
                ::avro::decode(d, v.counts);
                ::avro::decode(d, v.rmsDists);
                ::avro::decode(d, v.count);
                ::avro::decode(d, v.rmsDist);
                ::avro::decode(d, v.tolerance);
                ::avro::decode(d, v.numIters);
                ::avro::decode(d, v.info);
            }
        }
    };
} // end namespace avro

#endif // __AGGREGATE_K_MEANS_H__
